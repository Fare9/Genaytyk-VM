#-*- coding: utf-8 -*-
#============================================================
#
#       Disassembler para la máquina virtual del crackme
#       de genaytyk, esta tercera versión estará implementada
#       con una máquina de estados para manejar correctamente
#       el desensamblado, sacaremos la salida como un archivo
#       .asm
#
#============================================================

import os, sys
from pprint import pprint

version         = "2.0"
author          = "F9(@Farenain)"
date            = "2018/05/24"
module          = "vm_disassembler_x86.py"
description     = "*   F9 Reversing Tools   ***\n* Genaytyk VM x86 Disassembler ***"


hardcodedString = 'aAb0cBd1eCf2gDh3jEk4lFm5nGp6qHr7sJt8uKv9w'


'''
    Set de instrucciones de la máquina virtual,
    se irá ampliando según tengamos más instrucciones
'''
instructions = {1:"MOV",
                2:"ADD",
                3:"SUB",
                4:"IMUL",
                5:"IDIV",
                6:"OR",
                7:"XOR",
                8:"AND",
                9:"INC",
                0xA:"DEC",
                0xB:"NOT",
                0xC:"SHR",
                0xD:"SHL",
                0xE:"ROR",
                0xF:"ROL",
                0x10:"JMP",
                0x11:"JZ",
                0x12:"JNZ",
                0x13:"JA",
                0x14:"JB",
                0x15:"JNB",
                0x16:"JBE",
                0x17:"CALL",
                0x18:"PUSH",
                0x19:"POP",
                0x1A:"RET",
                0x1B:"NOP",
                0x1C:"PUSHAD",
                0x1D:"POPAD",
                0x1E:"ERROR"}


IMMEDIATE_OPCODE    = 0x49
SERIAL_HASH_OPCODE  = 0x4F
ADDRESS_OPCODE      = 0x51
REGISTER_OPCODE     = 0x52

BYTE    = 1
WORD    = 2
DWORD   = 4
QWORD   = 8

'''
    Esta estructura indica el tipo de operandos de la instrucción,
    indicado por el segundo opcode de una instrucción, esta estructura
    nos habla de cómo serán los siguientes opcodes de la instrucción
    (además de decirnos cuantos opcodes más habrá en la instrucción).

    El primer byte, nos dice el número de esta estructura que hay seguidas
    de esta estructura.
    El segundo byte, el número de opcodes que tendremos que coger para el 
    siguiente opcode.
    El tercer byte, indica el tipo de operando que se va a utiliar:
        IMMEDIATE_OPCODE = 49h
        ADDRESS_OPCODE = 51h
        REGISTER_OPCODE = 52h
'''
operandStruct = [[1,1,0x52],
                [1,3,0x4F],
                [1,1,0x51],
                [1,3,0x49],
                [1,4,0x49],
                [2,1,0x52,1,0x52],
                [2,1,0x52,3,0x4F],
                [2,1,0x52,1,0x51],
                [2,1,0x52,1,0x49],
                [2,1,0x52,2,0x49],
                [2,1,0x52,4,0x49],
                [2,3,0x4F,1,0x52],
                [2,3,0x4F,1,0x49],
                [2,3,0x4F,2,0x49],
                [2,3,0x4F,4,0x49],
                [2,1,0x51,1,0x52],
                [2,1,0x51,1,0x49],
                [2,1,0x51,2,0x49],
                [2,1,0x51,4,0x49],
                [3,3,0x49,1,0x52,1,0x52],
                [3,3,0x49,1,0x52,3,0x4F],
                [3,3,0x49,1,0x52,1,0x51],
                [3,3,0x49,1,0x52,1,0x49],
                [3,3,0x49,1,0x52,2,0x49],
                [3,3,0x49,1,0x52,4,0x49],
                [3,3,0x49,3,0x4F,1,0x52],
                [3,3,0x49,3,0x4F,1,0x49],
                [3,3,0x49,3,0x4F,2,0x49],
                [3,3,0x49,3,0x4F,4,0x49],
                [3,3,0x49,1,0x51,1,0x52],
                [3,3,0x49,1,0x51,1,0x49],
                [3,3,0x49,1,0x51,2,0x49],
                [3,3,0x49,1,0x51,4,0x49]]


'''
    La siguiente estructura nos da los datos necesarios
    para poder usar registros
'''
opcodesIndexOffsetSize = [[1,4,4, 'EAX'],
                        [2,8,4, 'EBX'],
                        [3,0xC,4, 'ECX'],
                        [4,0x10,4, 'EDX'],
                        [5,0x14,4, 'ESP'],
                        [6,0x18,4, 'EBP'],
                        [7,0x1C,4, 'EDI'],
                        [8,0x20,4, 'ESI'],
                        [9,0x24,4, 'REG0x24'],
                        [0xA,0x28,4, 'REG0x28'],
                        [0xB,0x2C,4],
                        [0xC,0x30,4],
                        [0xD,0x34,4],
                        [0xE,0x38,4],
                        [0xF,4,1, 'AL'],
                        [0x10,5,1, 'AH'],
                        [0x11,8,1, 'BL'],
                        [0x12,9,1, 'BH'],
                        [0x13,0xC,1, 'CL'],
                        [0x14,0xD,1, 'CH'],
                        [0x15,0x10,1,'DL'],
                        [0x16,0x11,1, 'DH'],
                        [0x17,4,2, 'AX'],
                        [0x18,8,2, 'BX'],
                        [0x19,0xC,2, 'CX'],
                        [0x1A,0x10,2, 'DX'],
                        [0x1B,0x14,2, 'SP'],
                        [0x1C,0x18,2, 'BP'],
                        [0x1D,0x1C,2, 'DI'],
                        [0x1E,0x20,2, 'SI']]


codeOfVM = [0x17 ,0x04 ,0x00 ,0x01 ,0xF9 ,                                  # CALL 0x1F9
            0x11 ,0x19 ,0x00 ,0x01 ,0xF8 ,0x01 ,0xFF ,0xFF ,0xFF, 0xFF ,    # CMP DWORD(REG0x4) ,0xffffffffL; JZ  0x1f8
            0x07 ,0x06 ,0x03 ,0x03 ,                                        # XOR DWORD(REG0xc) ,DWORD(REG0xc)
            0x01 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0xE0 ,                      # MOVE DWORD(REG0x1c) ,0xe0
            0x17 ,0x04, 0x00 ,0x02 ,0x5D ,                                  # CALL 0x25d
            0x12 ,0x19 ,0x00 ,0x01 ,0xF8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x06 ,    # CMP DWORD(REG0x4) ,0x6; JNZ  0x1f8
            0x02, 0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x07 ,                      # ADD DWORD(REG0x1c) ,0x7
            0x09 ,0x01 ,0x03 ,                                              # INC DWORD(REG0xc)
            0x12 ,0x19 ,0x00 ,0x00 ,0x1A, 0x03 ,0x00 ,0x00 ,0x00 ,0x03 ,    # CMP DWORD(REG0xc) ,0x3, JNZ  0x1a
            0x07 ,0x06 ,0x03 ,0x03 ,0x01 ,0x0B ,0x07 ,0x00 ,0x00, 
            0x00 ,0xE0 ,0x17 ,0x04 ,0x00 ,0x02 ,0x7D ,0x09 ,0x01 ,0x07 ,0x09 ,0x01 ,0x03 ,0x12, 
            0x19 ,0x00 ,0x00 ,0x48 ,0x03 ,0x00 ,0x00 ,0x00 ,0x03 ,0x07 ,0x06 ,0x03 ,0x03 ,0x01, 
            0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0xE0 ,0x01 ,0x0B ,0x02 ,0x00 ,0x00 ,0x00 ,0x9B ,0x17, 
            0x04 ,0x00 ,0x02 ,0xAF ,0x11 ,0x19 ,0x00 ,0x01 ,0xF8 ,0x01 ,0xFF ,0xFF ,0xFF ,0xFF, 
            0x01 ,0x10 ,0x02 ,0x01 ,0x02 ,0x0B ,0x02 ,0x00 ,0x00 ,0x00 ,0x04 ,0x02 ,0x0B ,0x07, 
            0x00 ,0x00 ,0x00 ,0x07 ,0x09 ,0x01 ,0x03 ,0x12 ,0x19 ,0x00 ,0x00 ,0x6F ,0x03 ,0x00, 
            0x00 ,0x00 ,0x03 ,0x01 ,0x07 ,0x09 ,0x00 ,0x00 ,0x9B ,0x0F ,0x09 ,0x09 ,0x07 ,0x01, 
            0x0C ,0x00 ,0x00 ,0x9B ,0x09 ,0x01 ,0x07 ,0x09 ,0x00 ,0x00 ,0x9F ,0x0E ,0x09 ,0x09, 
            0x09 ,0x01 ,0x0C ,0x00 ,0x00 ,0x9F ,0x09 ,0x01 ,0x07 ,0x09 ,0x00 ,0x00 ,0xA3 ,0x0E, 
            0x09 ,0x09 ,0x0B ,0x01 ,0x0C ,0x00 ,0x00 ,0xA3 ,0x09 ,0x01 ,0x07 ,0x01 ,0x00 ,0x00, 
            0x9F ,0x07 ,0x0C ,0x00 ,0x00 ,0x9B ,0x01 ,0x02 ,0x0C ,0x00 ,0x00 ,0xA3 ,0x01 ,0x01, 
            0x07 ,0x01 ,0x00 ,0x00 ,0x9B ,0x03 ,0x0C ,0x00 ,0x00 ,0xA3 ,0x01 ,0x17 ,0x04 ,0x00, 
            0x02 ,0xFF ,0x17 ,0x04 ,0x00 ,0x04 ,0x17 ,0x01 ,0x0C ,0x00 ,0x00 ,0xA7 ,0x01 ,0x17, 
            0x04 ,0x00 ,0x03 ,0x6C ,0x01 ,0x07 ,0x01 ,0x00 ,0x00 ,0x9B ,0x01 ,0x0C ,0x00 ,0x00, 
            0x93 ,0x01 ,0x01 ,0x07 ,0x01 ,0x00 ,0x00 ,0x9F ,0x01 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00, 
            0x93 ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x10 ,0x09 ,0x01 ,0x01 ,0x0B, 
            0x03 ,0x00 ,0x00 ,0x00 ,0x0A ,0x01 ,0x0B ,0x04 ,0x00 ,0x00 ,0x00 ,0xAB ,0x01 ,0x0B, 
            0x01 ,0x00 ,0x00 ,0x00 ,0x93 ,0x17 ,0x04 ,0x00 ,0x04 ,0x58 ,0x0A ,0x01 ,0x13 ,0x12, 
            0x17 ,0x00 ,0x01 ,0x2B ,0x13 ,0x00 ,0x17 ,0x04 ,0x00 ,0x03 ,0xF2 ,0x01 ,0x0B ,0x09, 
            0x00 ,0x00 ,0x00 ,0x93 ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x12 ,0x16 ,0x00, 
            0x01 ,0xF8 ,0x01 ,0x09 ,0x01 ,0x07 ,0x01 ,0x00 ,0x00 ,0xA3 ,0x01 ,0x0B ,0x09 ,0x00, 
            0x00 ,0x00 ,0x93 ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x10 ,0x09 ,0x01, 
            0x01 ,0x07 ,0x01 ,0x00 ,0x00 ,0xA7 ,0x01 ,0x0C ,0x00 ,0x00 ,0xB3 ,0x01 ,0x01 ,0x0B, 
            0x09 ,0x00 ,0x00 ,0x00 ,0xB3 ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x13, 
            0x09 ,0x6B ,0x79 ,0x74 ,0x5F ,0x01 ,0x0B ,0x03 ,0x00 ,0x00 ,0x00 ,0x0F ,0x01 ,0x0B, 
            0x04 ,0x00 ,0x00 ,0x00 ,0xB3 ,0x01 ,0x0B ,0x01 ,0x00 ,0x00 ,0x00 ,0x93 ,0x17 ,0x04, 
            0x00 ,0x04 ,0x58 ,0x0A ,0x01 ,0x03 ,0x12 ,0x19 ,0x00 ,0x01 ,0xA2 ,0x03 ,0x00 ,0x00, 
            0x00 ,0x00 ,0x01 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x93 ,0x01 ,0x0B ,0x08 ,0x00 ,0x00, 
            0x00 ,0x2A ,0x07 ,0x06 ,0x03 ,0x03 ,0x01 ,0x08 ,0x0F ,0x07 ,0x12 ,0x16 ,0x00 ,0x01, 
            0xF8 ,0x0F ,0x08 ,0x09 ,0x01 ,0x07 ,0x09 ,0x01 ,0x08 ,0x09 ,0x01 ,0x03 ,0x12 ,0x19, 
            0x00 ,0x01 ,0xD4 ,0x03 ,0x00 ,0x00 ,0x00 ,0x08 ,0x01 ,0x0D ,0x00 ,0x01 ,0x09 ,0x01, 
            0x1E ,0x07 ,0x06 ,0x01 ,0x01 ,0x07 ,0x06 ,0x04 ,0x04 ,0x01 ,0x0B ,0x07 ,0x00 ,0x00, 
            0x00 ,0xE0 ,0x01 ,0x08 ,0x0F ,0x07 ,0x12 ,0x17 ,0x00 ,0x02 ,0x1F ,0x0F ,0x2D ,0x09, 
            0x01 ,0x04 ,0x01 ,0x11 ,0x07 ,0x00 ,0x10 ,0x04 ,0x00 ,0x02 ,0x3C ,0x01 ,0x0B ,0x03, 
            0x00 ,0x00 ,0x00 ,0x00 ,0x11 ,0x16 ,0x00 ,0x02 ,0x3C ,0x0F ,0x03 ,0x09 ,0x01 ,0x03, 
            0x12 ,0x1F ,0x00 ,0x02 ,0x26 ,0x03 ,0x00 ,0x10 ,0x04 ,0x00 ,0x02 ,0x55 ,0x09 ,0x01, 
            0x07 ,0x12 ,0x1F ,0x00 ,0x02 ,0x08 ,0x07 ,0x00 ,0x12 ,0x19 ,0x00 ,0x02 ,0x55 ,0x04, 
            0x00 ,0x00 ,0x00 ,0x02 ,0x07 ,0x06 ,0x01 ,0x01 ,0x1A ,0x01 ,0x0B ,0x01 ,0xFF ,0xFF, 
            0xFF ,0xFF ,0x1A ,0x01 ,0x06 ,0x08 ,0x07 ,0x01 ,0x08 ,0x0F ,0x08 ,0x11 ,0x17 ,0x00, 
            0x02 ,0x74 ,0x0F ,0x00 ,0x09 ,0x01 ,0x08 ,0x10 ,0x04 ,0x00 ,0x02 ,0x61 ,0x03 ,0x06, 
            0x08 ,0x07 ,0x01 ,0x06 ,0x01 ,0x08 ,0x1A ,0x07 ,0x06 ,0x04 ,0x04 ,0x01 ,0x08 ,0x0F, 
            0x07 ,0x01 ,0x0B ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0A ,0x01 ,0x02 ,0x09 ,0x01 ,0x02, 
            0x12 ,0x16 ,0x00 ,0x02 ,0x8F ,0x0F ,0x02 ,0x03 ,0x0B ,0x02 ,0x00 ,0x00 ,0x00 ,0x00, 
            0x01 ,0x10 ,0x07 ,0x11 ,0x09 ,0x01 ,0x07 ,0x12 ,0x1F ,0x00 ,0x02 ,0x7D ,0x07 ,0x00, 
            0x1A ,0x18 ,0x01 ,0x02 ,0x07 ,0x06 ,0x02 ,0x02 ,0x07 ,0x06 ,0x01 ,0x01 ,0x01 ,0x06, 
            0x04 ,0x07 ,0x02 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x05 ,0x03 ,0x0B ,0x04 ,0x00 ,0x00, 
            0x00 ,0x01 ,0x01 ,0x0B ,0x08 ,0x00 ,0x00 ,0x00 ,0x01 ,0x07 ,0x06 ,0x01 ,0x01 ,0x01, 
            0x08 ,0x0F ,0x07 ,0x04 ,0x06 ,0x01 ,0x08 ,0x02 ,0x06 ,0x02 ,0x01 ,0x04 ,0x0B ,0x08, 
            0x00 ,0x00 ,0x00 ,0x29 ,0x0A ,0x01 ,0x07 ,0x12 ,0x14 ,0x00 ,0x02 ,0xD3 ,0x07 ,0x04, 
            0x09 ,0x01 ,0x07 ,0x01 ,0x06 ,0x01 ,0x02 ,0x19 ,0x01 ,0x02 ,0x1A ,0x01 ,0x0B ,0x08, 
            0x00 ,0x00 ,0x00 ,0xBB ,0x01 ,0x06 ,0x04 ,0x08 ,0x02 ,0x07 ,0x04 ,0x00 ,0x01 ,0x05, 
            0x01 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x33 ,0x02 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x5F, 
            0x07 ,0x06 ,0x03 ,0x03 ,0x07 ,0x06 ,0x01 ,0x01 ,0x07 ,0x08 ,0x0F ,0x08 ,0x07 ,0x09, 
            0x0F ,0x75 ,0x02 ,0x06 ,0x0F ,0x13 ,0x02 ,0x0B ,0x03 ,0x00 ,0x00 ,0x00 ,0x03 ,0x07, 
            0x0B ,0x03 ,0x00 ,0x00 ,0x00 ,0x45 ,0x0F ,0x09 ,0x03 ,0x03 ,0x09 ,0x01 ,0x08 ,0x01, 
            0x10 ,0x07 ,0x0F ,0x11 ,0x19 ,0x00 ,0x03 ,0x6B ,0x07 ,0x00 ,0x00 ,0x00 ,0x33 ,0x0A, 
            0x01 ,0x07 ,0x12 ,0x14 ,0x00 ,0x03 ,0x26 ,0x08 ,0x04 ,0x01 ,0x0B ,0x08 ,0x00 ,0x00, 
            0x00 ,0xBB ,0x10 ,0x04 ,0x00 ,0x03 ,0x26 ,0x1A ,0x01 ,0x0B ,0x01 ,0x13 ,0xA1 ,0xDC, 
            0xB4 ,0x01 ,0x0B ,0x02 ,0x45 ,0xE8 ,0xAD ,0xC1 ,0x01 ,0x0B ,0x03 ,0x00 ,0x00 ,0x00, 
            0x28 ,0x01 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x33 ,0x01 ,0x06 ,0x08 ,0x07 ,0x02 ,0x0B, 
            0x08 ,0x00 ,0x00 ,0x00 ,0x30 ,0x01 ,0x06 ,0x04 ,0x08 ,0x07 ,0x08 ,0x01 ,0x07 ,0x0F, 
            0x09 ,0x01 ,0x03 ,0x02 ,0x08 ,0x01 ,0x08 ,0x02 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x04, 
            0x02 ,0x0B ,0x08 ,0x00 ,0x00 ,0x00 ,0x04 ,0x12 ,0x14 ,0x00 ,0x03 ,0x97 ,0x07 ,0x04, 
            0x07 ,0x06 ,0x01 ,0x02 ,0x01 ,0x06 ,0x09 ,0x01 ,0x01 ,0x06 ,0x0A ,0x02 ,0x01 ,0x06, 
            0x02 ,0x09 ,0x01 ,0x06 ,0x01 ,0x0A ,0x0A ,0x01 ,0x03 ,0x12 ,0x19 ,0x00 ,0x03 ,0x81, 
            0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x0C ,0x00 ,0x00 ,0xAB ,0x01 ,0x01 ,0x0B ,0x09, 
            0x00 ,0x00 ,0x00 ,0xAB ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x10 ,0x09, 
            0x02 ,0x1A ,0x07 ,0x06 ,0x01 ,0x01 ,0x01 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x33 ,0x01, 
            0x06 ,0x08 ,0x07 ,0x02 ,0x0B ,0x08 ,0x00 ,0x00 ,0x00 ,0x5D ,0x02 ,0x08 ,0x01 ,0x07, 
            0x09 ,0x01 ,0x07 ,0x12 ,0x14 ,0x00 ,0x04 ,0x08 ,0x07 ,0x08 ,0x1A ,0x01 ,0x0B ,0x01, 
            0x1A ,0x2B ,0x3C ,0x4D ,0x01 ,0x0B ,0x03 ,0x00 ,0x00 ,0x00 ,0xFF ,0x01 ,0x0B ,0x07, 
            0x00 ,0x00 ,0x00 ,0x33 ,0x01 ,0x06 ,0x08 ,0x07 ,0x02 ,0x0B ,0x08 ,0x00 ,0x00 ,0x00, 
            0x5D ,0x01 ,0x08 ,0x02 ,0x07 ,0x07 ,0x06 ,0x01 ,0x02 ,0x0F ,0x09 ,0x01 ,0x07 ,0x09, 
            0x01 ,0x07 ,0x12 ,0x14 ,0x00 ,0x04 ,0x37 ,0x07 ,0x08 ,0x0A ,0x01 ,0x13 ,0x12 ,0x17, 
            0x00 ,0x04 ,0x25 ,0x13 ,0x00 ,0x1A ,0x1C ,0x18 ,0x01 ,0x01 ,0x01 ,0x08 ,0x03 ,0x04, 
            0x01 ,0x0C ,0x00 ,0x01 ,0x0A ,0x03 ,0x01 ,0x06 ,0x09 ,0x04 ,0x02 ,0x0B ,0x09 ,0x00, 
            0x00 ,0x00 ,0x04 ,0x01 ,0x08 ,0x03 ,0x09 ,0x01 ,0x0B ,0x09 ,0x00 ,0x00 ,0x01 ,0x0A, 
            0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x10 ,0x09 ,0x03 ,0x17 ,0x04 ,0x00, 
            0x06 ,0x82 ,0x01 ,0x06 ,0x08 ,0x01 ,0x19 ,0x01 ,0x07 ,0x07 ,0x06 ,0x01 ,0x01 ,0x01, 
            0x0B ,0x03 ,0x00 ,0x00 ,0x00 ,0x64 ,0x07 ,0x06 ,0x02 ,0x02 ,0x01 ,0x06 ,0x09 ,0x07, 
            0x01 ,0x06 ,0x02 ,0x09 ,0x02 ,0x0B ,0x02 ,0x00 ,0x00 ,0x00 ,0x07 ,0x01 ,0x06 ,0x0A, 
            0x04 ,0x01 ,0x08 ,0x0F ,0x09 ,0x07 ,0x08 ,0x0F ,0x0A ,0x09 ,0x01 ,0x0A ,0x03 ,0x08, 
            0x0F ,0x0A ,0x0A ,0x01 ,0x0A ,0x02 ,0x09 ,0x0F ,0x12 ,0x01 ,0x10 ,0x09 ,0x0F ,0x09, 
            0x01 ,0x0A ,0x09 ,0x01 ,0x09 ,0x12 ,0x14 ,0x00 ,0x04 ,0xB5 ,0x09 ,0x02 ,0x07 ,0x06, 
            0x02 ,0x02 ,0x01 ,0x06 ,0x09 ,0x07 ,0x01 ,0x08 ,0x0A ,0x09 ,0x0F ,0x09 ,0x0A ,0x03, 
            0x01 ,0x10 ,0x09 ,0x0A ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x08 ,0x0A, 
            0x09 ,0x0E ,0x09 ,0x0A ,0x03 ,0x01 ,0x10 ,0x09 ,0x0A ,0x01 ,0x06 ,0x09 ,0x07 ,0x01, 
            0x06 ,0x0A ,0x04 ,0x01 ,0x08 ,0x01 ,0x0A ,0x07 ,0x10 ,0x09 ,0x01 ,0x02 ,0x0B ,0x0A, 
            0x00 ,0x00 ,0x00 ,0x04 ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x08 ,0x01, 
            0x0A ,0x07 ,0x10 ,0x09 ,0x01 ,0x01 ,0x06 ,0x09 ,0x07 ,0x01 ,0x06 ,0x0A ,0x04 ,0x02, 
            0x10 ,0x09 ,0x01 ,0x01 ,0x08 ,0x01 ,0x0A ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04, 
            0x02 ,0x10 ,0x09 ,0x01 ,0x09 ,0x01 ,0x02 ,0x12 ,0x19 ,0x00 ,0x04 ,0xE0 ,0x02 ,0x00, 
            0x00 ,0x00 ,0x10 ,0x07 ,0x06 ,0x02 ,0x02 ,0x01 ,0x0B ,0x06 ,0x00 ,0x00 ,0x00 ,0x20, 
            0x17 ,0x04 ,0x00 ,0x07 ,0x64 ,0x11 ,0x19 ,0x00 ,0x05 ,0xA9 ,0x01 ,0x00 ,0x00 ,0x00, 
            0x00 ,0x18 ,0x01 ,0x06 ,0x16 ,0x19 ,0x00 ,0x05 ,0x89 ,0x06 ,0x00 ,0x00 ,0x00 ,0x07, 
            0x03 ,0x0B ,0x06 ,0x00 ,0x00 ,0x00 ,0x07 ,0x13 ,0x19 ,0x00 ,0x05 ,0x78 ,0x06 ,0x00, 
            0x00 ,0x00 ,0x07 ,0x01 ,0x06 ,0x09 ,0x04 ,0x02 ,0x06 ,0x09 ,0x02 ,0x01 ,0x08 ,0x0F, 
            0x09 ,0x01 ,0x06 ,0x09 ,0x07 ,0x02 ,0x06 ,0x09 ,0x06 ,0x07 ,0x10 ,0x09 ,0x0F ,0x19, 
            0x01 ,0x06 ,0x10 ,0x04 ,0x00 ,0x05 ,0xD9 ,0x18 ,0x01 ,0x02 ,0x16 ,0x19 ,0x00 ,0x05, 
            0xC7 ,0x02 ,0x00 ,0x00 ,0x00 ,0x07 ,0x03 ,0x0B ,0x02 ,0x00 ,0x00 ,0x00 ,0x07 ,0x13, 
            0x19 ,0x00 ,0x05 ,0xB6 ,0x02 ,0x00 ,0x00 ,0x00 ,0x07 ,0x01 ,0x06 ,0x09 ,0x07 ,0x02, 
            0x06 ,0x09 ,0x02 ,0x0B ,0x03 ,0x09 ,0x07 ,0x10 ,0x09 ,0x11 ,0x19 ,0x01 ,0x02 ,0x09, 
            0x01 ,0x02 ,0x14 ,0x19 ,0x00 ,0x05 ,0xEA ,0x02 ,0x00 ,0x00 ,0x00 ,0x08 ,0x07 ,0x06, 
            0x02 ,0x02 ,0x0A ,0x01 ,0x06 ,0x12 ,0x19 ,0x00 ,0x05 ,0x5C ,0x06 ,0x00 ,0x00 ,0x00, 
            0x00 ,0x07 ,0x06 ,0x02 ,0x02 ,0x01 ,0x06 ,0x09 ,0x07 ,0x01 ,0x08 ,0x0F ,0x09 ,0x18, 
            0x01 ,0x07 ,0x02 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x07 ,0x03 ,0x06 ,0x07 ,0x02 ,0x07, 
            0x10 ,0x07 ,0x0F ,0x19 ,0x01 ,0x07 ,0x01 ,0x08 ,0x0F ,0x09 ,0x0F ,0x09 ,0x0F ,0x03, 
            0x01 ,0x10 ,0x09 ,0x0F ,0x09 ,0x01 ,0x09 ,0x09 ,0x01 ,0x02 ,0x12 ,0x19 ,0x00 ,0x05, 
            0xFF ,0x02 ,0x00 ,0x00 ,0x00 ,0x08 ,0x01 ,0x06 ,0x09 ,0x07 ,0x01 ,0x08 ,0x01 ,0x09, 
            0x0F ,0x09 ,0x01 ,0x07 ,0x01 ,0x10 ,0x09 ,0x01 ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00, 
            0x04 ,0x01 ,0x08 ,0x01 ,0x09 ,0x0E ,0x09 ,0x01 ,0x07 ,0x01 ,0x10 ,0x09 ,0x01 ,0x0A, 
            0x01 ,0x03 ,0x12 ,0x19 ,0x00 ,0x04 ,0x9E ,0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x0B, 
            0x09 ,0x00 ,0x00 ,0x01 ,0x0A ,0x01 ,0x13 ,0x09 ,0x00 ,0x00 ,0x00 ,0x00 ,0x02 ,0x0B, 
            0x09 ,0x00 ,0x00 ,0x00 ,0x04 ,0x01 ,0x13 ,0x09 ,0x00 ,0x00 ,0x00 ,0x00 ,0x1D ,0x1A, 
            0x07 ,0x06 ,0x02 ,0x02 ,0x01 ,0x0B ,0x09 ,0x00 ,0x00 ,0x01 ,0x0A ,0x09 ,0x01 ,0x09, 
            0x02 ,0x06 ,0x09 ,0x02 ,0x01 ,0x08 ,0x0F ,0x09 ,0x0A ,0x01 ,0x09 ,0x02 ,0x10 ,0x09, 
            0x0F ,0x03 ,0x10 ,0x09 ,0x11 ,0x01 ,0x0B ,0x09 ,0x00 ,0x00 ,0x01 ,0x0A ,0x01 ,0x08, 
            0x01 ,0x09 ,0x0F ,0x09 ,0x01 ,0x05 ,0x01 ,0x10 ,0x09 ,0x01 ,0x02 ,0x0B ,0x09 ,0x00, 
            0x00 ,0x00 ,0x04 ,0x01 ,0x08 ,0x01 ,0x09 ,0x0E ,0x09 ,0x01 ,0x05 ,0x01 ,0x10 ,0x09, 
            0x01 ,0x09 ,0x01 ,0x02 ,0x12 ,0x19 ,0x00 ,0x06 ,0x86 ,0x02 ,0x00 ,0x00 ,0x00 ,0x07, 
            0x07 ,0x06 ,0x01 ,0x01 ,0x07 ,0x06 ,0x02 ,0x02 ,0x07 ,0x06 ,0x03 ,0x03 ,0x01 ,0x0B, 
            0x07 ,0x00 ,0x00 ,0x00 ,0x45 ,0x01 ,0x0B ,0x09 ,0x00 ,0x00 ,0x01 ,0x0A ,0x02 ,0x06, 
            0x09 ,0x02 ,0x01 ,0x08 ,0x0F ,0x09 ,0x02 ,0x06 ,0x03 ,0x01 ,0x04 ,0x06 ,0x07 ,0x07, 
            0x09 ,0x01 ,0x03 ,0x04 ,0x06 ,0x03 ,0x07 ,0x09 ,0x01 ,0x02 ,0x12 ,0x19 ,0x00 ,0x06, 
            0xE9 ,0x02 ,0x00 ,0x00 ,0x00 ,0x04 ,0x18 ,0x01 ,0x03 ,0x07 ,0x06 ,0x01 ,0x01 ,0x07, 
            0x06 ,0x02 ,0x02 ,0x07 ,0x06 ,0x03 ,0x03 ,0x01 ,0x0B ,0x07 ,0x00 ,0x00 ,0x00 ,0x35, 
            0x01 ,0x0B ,0x09 ,0x00 ,0x00 ,0x01 ,0x0A ,0x02 ,0x0B ,0x09 ,0x00 ,0x00 ,0x00 ,0x04, 
            0x02 ,0x06 ,0x09 ,0x02 ,0x01 ,0x08 ,0x0F ,0x09 ,0x03 ,0x06 ,0x03 ,0x01 ,0x04 ,0x06, 
            0x07 ,0x07 ,0x09 ,0x01 ,0x03 ,0x04 ,0x06 ,0x03 ,0x07 ,0x09 ,0x01 ,0x02 ,0x12 ,0x19, 
            0x00 ,0x07 ,0x2A ,0x02 ,0x00 ,0x00 ,0x00 ,0x04 ,0x19 ,0x01 ,0x01 ,0x04 ,0x06 ,0x01, 
            0x03 ,0x1A ,0x18 ,0x01 ,0x06 ,0x18 ,0x01 ,0x08 ,0x01 ,0x0B ,0x01 ,0x00 ,0x00 ,0x00, 
            0x01 ,0x10 ,0x04 ,0x00 ,0x07 ,0x7A ,0x0D ,0x09 ,0x01 ,0x01 ,0x0A ,0x01 ,0x06 ,0x12, 
            0x19 ,0x00 ,0x07 ,0x76 ,0x06 ,0xFF ,0xFF ,0xFF ,0xFF ,0x08 ,0x06 ,0x08 ,0x01 ,0x11, 
            0x19 ,0x00 ,0x07 ,0xA1 ,0x08 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x0B ,0x01 ,0x00 ,0x00, 
            0x00 ,0x01 ,0x10 ,0x04 ,0x00 ,0x07 ,0xA5 ,0x07 ,0x06 ,0x01 ,0x01 ,0x19 ,0x01 ,0x08, 
            0x19 ,0x01 ,0x06 ,0x1A] 


INDEX = 0      
CALL_JMP = False
JMP_OP = False
IS_RET = False
IS_IN_CALL = False
RET = 0
Function_Name = ""
LIST_OF_FUNCTION_OFFSETS = []

# Estados posibles
SETUP = 0
INIT = 98
GET_OPERATION = 1
GET_OPERANDS = 2
GET_JC_OPERANDS = 3
END_CALL = 4
END_RET = 5
END_NORMAL = 6
ERROR_STATE = 99

ESTADO = SETUP


byte_registers = ['AL','BL','CL','DL','AH','BH','CH','DH']

word_registers = ['AX','BX','CX','DX','DI','SI','SP','BP']

dword_registers = ['EAX','EBX','ECX','EDX','EDI','ESI','ESP','EBP','REG0x24','REG0x28']

def getOperation(opcode):
    '''
    Función para obtener la operación del opcode
    '''
    global instructions

    instToReturn = ''
    try:
        instToReturn = instructions[opcode]
        print "[+] Instruction: %s" % (instToReturn)
        return instToReturn
    except Exception as e:
        print "[-] I think that is not an instruction"
        return None


def getOperandStruct(opcode):
    '''
    Funcion para obtener la estructura adecuada de operandStruct
    '''
    global operandStruct

    if opcode < 1 or opcode > len(operandStruct):
        return None
    else:
        aux = opcode - 1 # ya que en la lista empezamos a contar desde 0
        return operandStruct[aux]

def getDictsFromOperandStruct(operandStruct):
    '''
    Esta función una vez obtenida la linea de operandStruct que nos interesaba
    nos devuelve una lista de diccionarios con el tamaño del operando en opcodes
    y el tipo
    '''
    operandos = []
    if operandStruct[0] <= 3 and operandStruct[0] >= 1:
        aux = {"size":operandStruct[1],"type":operandStruct[2]}
        operandos.append(aux)

    if operandStruct[0] <= 3 and operandStruct[0] >= 2:
        aux = {"size":operandStruct[3],"type":operandStruct[4]}
        operandos.append(aux)

    if operandStruct[0] == 3:
        aux = {"size":operandStruct[5],"type":operandStruct[6]}
        operandos.append(aux)

    return operandos

def getImmediateValue(sizeOfImmediate):
    '''
    Función para obtener un valor inmediato, con el tamaño pedimos al usuario
    un número de opcodes predeterminados.
    '''
    global codeOfVM
    global INDEX

    value = 0
    while sizeOfImmediate != 0:
        try:
            aux = codeOfVM[INDEX]
            INDEX += 1
            aux = aux
            value += (aux << (8 * (sizeOfImmediate - 1))) 
            sizeOfImmediate -= 1
        except ValueError as ve:
            print "[-] I think that is not a valid hexadecimal number"       

    print "[+] Immediate number to return: 0x%08x" % (value)
    return value

def getRegister(opcode):
    '''
    Función para obtener registro según número
    '''
    global opcodesIndexOffsetSize

    register = "REG"
    for i in opcodesIndexOffsetSize:
        if opcode == i[0]:
            register = i[3]
            print "Register: %s" % (register)
            return register
    return None

def AddPrefixMov(instruction):
    '''
    Método para añadir los siguientes prefijos:
        -   byte ptr
        -   word ptr
        -   dword ptr
    '''
    print "[+] Instruction to resolve: " + instruction

    operation = instruction.split(' ')[0]

    if operation in ['NOT','INC','DEC','CALL']:
        return instruction.replace('[HardcodedString','dword ptr [HardcodedString')

    operand_1 = instruction.split(', ')[0].strip(' ').replace(operation + ' ', '')
    operand_2 = instruction.split(', ')[1].strip(' ')

    if operand_1 in byte_registers:
        operand_2 = "byte ptr " + operand_2
    elif operand_1 in word_registers:
        operand_2 = "word ptr " + operand_2
    elif operand_1 in dword_registers:
        operand_2 = "dword ptr " + operand_2

    if operand_2 in byte_registers:
        operand_1 = "byte ptr " + operand_1
    elif operand_2 in word_registers:
        operand_1 = "word ptr " + operand_1
    elif operand_2 in dword_registers:
        operand_1 = "dword ptr " + operand_1
    elif operand_2[0] == '0' and operand_2[-1] == 'h':
        operand_1 = "dword ptr " + operand_1

    print "[+] Operation: " + operation
    print "[+] Operand_1: " + operand_1
    print "[+] Operand_2: " + operand_2

    return operation + " " + operand_1 + " , " + operand_2

def FixDoubleENDP():
    '''
    Función para quitar el primer VIRTUAL_FUNCTION_000001f9...
    es una guarrada hacerlo así... pero no me mireis :(
    '''
    archivo = open('vm_instructions.asm','r')

    lineas = []

    borrado_primera_instancia = False

    for line in archivo.readlines():
        if ('VIRTUAL_FUNCTION_000001F9' in line) and ('endp' in line) and (not borrado_primera_instancia):
            borrado_primera_instancia = True
        else:
            lineas.append(line)

    archivo.close()

    archivo = open('vm_instructions.asm','w')

    for line in lineas:
        archivo.write(line)

    archivo.close()

def FixFalseRegisters(instruction):
    '''
    Arreglar los problemas de cuando aparece un REG0x24 o REG0x28
    al usar variables para estos "registros" tendremos que cambiarlos
    por código correspondiente que use un registro
    '''
    finalInstruct = ""

    print "[+] Instruction to modify: " + instruction
    
    RegisterToUse = "ECX"

    if RegisterToUse in instruction:
        RegisterToUse = "EBX"

    if "REG0x28" in instruction and "REG0x24" in instruction:
        finalInstruct += "push ECX\n"
        finalInstruct += "\t\t\t\tpush EBX\n"
        finalInstruct += "\t\t\t\tMOV ECX , dword ptr [REG0x24]\n"
        finalInstruct += "\t\t\t\tMOV EBX , dword ptr [REG0x28]\n"
        finalInstruct += "\t\t\t\t" + instruction.replace("REG0x24","ECX").replace("REG0x28","EBX") + "\n"
        finalInstruct += "\t\t\t\tMOV dword ptr [REG0x28] , EBX\n"
        finalInstruct += "\t\t\t\tMOV dword ptr [REG0x24] , ECX\n"
        finalInstruct += "\t\t\t\tpop EBX\n"
        finalInstruct += "\t\t\t\tpop ECX\n"
    elif "REG0x28" in instruction:
        finalInstruct += "push %s\n" % (RegisterToUse)
        finalInstruct += "\t\t\t\tMOV %s , [REG0x28]\n" % (RegisterToUse)
        finalInstruct += "\t\t\t\t" + instruction.replace("REG0x28",RegisterToUse) + "\n"
        finalInstruct += "\t\t\t\tMOV dword ptr [REG0x28] , %s\n" % (RegisterToUse)
        finalInstruct += "\t\t\t\tpop %s\n" % (RegisterToUse)
    elif "REG0x24" in instruction:
        finalInstruct += "push %s\n" % (RegisterToUse)
        finalInstruct += "\t\t\t\tMOV %s , [REG0x24]\n" % (RegisterToUse)
        finalInstruct += "\t\t\t\t" + instruction.replace("REG0x24",RegisterToUse) + "\n"
        finalInstruct += "\t\t\t\tMOV dword ptr [REG0x24] , %s\n" % (RegisterToUse)
        finalInstruct += "\t\t\t\tpop %s\n" % (RegisterToUse)
   
    return finalInstruct





def scripter_pipter():
    '''
    Intérprete de la VM, se meterá como una máquina de estados
    '''
    global codeOfVM
    global INDEX 
    global CALL_JMP
    global IS_RET
    global RET
    global Function_Name
    global ESTADO
    global LIST_OF_FUNCTION_OFFSETS

    while True:
        if ESTADO == SETUP:
            OFFSET = ""
            hash_offset = 0
            instruction = ""
            CALL_JMP = False
            JMP_OP = False
            IS_RET = False
            IS_IN_CALL = False
            archivo = open('vm_instructions.asm','w')
            archivo.write(";****************************************\n")
            archivo.write(";* Version: "+version+"\n")
            archivo.write(";* Author: "+author+"\n")
            archivo.write(";* Date: "+date+"\n")
            archivo.write(";* Module: "+module+"\n")
            archivo.write(";****************************************\n")

            archivo.write("\n\n\n")

            archivo.write(".486\n")
            archivo.write(".model flat, stdcall\n")
            archivo.write(".stack 100h\n")
            archivo.write("option casemap :none\n\n\n\n")

            archivo.write(".data\n\n")
            archivo.write("%s db '%s',0\n" % ("HardcodedString",hardcodedString))
            archivo.write("aOkay_guy db 'OKAY_GUY',0\n")
            archivo.write("hashedName db 05Fh dup(0)\n")
            archivo.write("db 9 dup(0)\n")
            archivo.write("MySerialHash dd 0\n\tdd 0\n\tdd 0\n")
            archivo.write("db 014h dup(0)\n")
            archivo.write("MyName db 025h dup(0)\n")
            archivo.write("MySerial db 025h dup(0)\n")
            archivo.write("nameLength dd 0\n")
            archivo.write("finalComparation dd 0\n")
            archivo.write("REG0x24 dd 0\n")
            archivo.write("REG0x28 dd 0\n\n\n")
            archivo.write(".code\n\n")
            archivo.write("start:\n")

            ESTADO = GET_OPERATION
            continue

        elif ESTADO == INIT:
            if INDEX >= len(codeOfVM):
                archivo.write("end start")
                archivo.close()
                FixDoubleENDP()
                print "\n\n\n[!] Finished disassembling of VM code..."
                print "Thanks for using vm_disassembler"
                break

            OFFSET = 0
            instruction = ""

            ESTADO = GET_OPERATION
            continue

        elif ESTADO == GET_OPERATION:

            if INDEX in LIST_OF_FUNCTION_OFFSETS:
                IS_IN_CALL = True
                Function_Name = "VIRTUAL_FUNCTION_%08X" % INDEX
                archivo.write("\n%s\tproc\n\n" % Function_Name)

            archivo.write("Label_%08X:\t" % INDEX)

            CALL_JMP = False

            IS_RET = False

            JMP_OP = False

            '''
                Checkea si operación de un solo opcode (RET, PUSHAD, POPAD, NOP)
            '''
            if codeOfVM[INDEX] == 0x1A: # RET
                instruction += getOperation(codeOfVM[INDEX]) + " "
                INDEX += 1
                IS_RET = True
                ESTADO = END_NORMAL
                continue
            elif codeOfVM[INDEX] == 0x1B: # NOP
                instruction += getOperation(codeOfVM[INDEX]) + " "
                INDEX += 1
                ESTADO = END_NORMAL
                continue
            elif codeOfVM[INDEX] == 0x1C: # PUSHAD
                instruction += getOperation(codeOfVM[INDEX]) + " "
                INDEX += 1
                ESTADO = END_NORMAL
                continue
            elif codeOfVM[INDEX] == 0x1D: # POPAD
                instruction += getOperation(codeOfVM[INDEX]) + " "
                INDEX += 1
                ESTADO = END_NORMAL
                continue
            elif codeOfVM[INDEX] == 0x1E: # ERROR OPCODE
                instruction += "INT 3"
                INDEX += 1
                ESTADO = END_NORMAL
                continue
            elif codeOfVM[INDEX] == 0x17: # CALL
                CALL_JMP = True
            elif codeOfVM[INDEX] == 0x10: # JMP
                JMP_OP = True

            two_opcodes = [codeOfVM[INDEX],codeOfVM[INDEX + 1]]
            INDEX += 2

            try:
                instruction += getOperation(two_opcodes[0]) + " "
            except TypeError as e:
                print "[-] Error getting operation...Instruction opcode %02x is not defined" % (two_opcodes[0])
                exit(0)

            operandStruct = getOperandStruct(two_opcodes[1])
            dictsOfOperands = getDictsFromOperandStruct(operandStruct)

            print "[+] Operand struct: " + str(operandStruct)

            if two_opcodes[0] >= 0x11 and two_opcodes[0] <= 0x16:
                ESTADO = GET_JC_OPERANDS
            else:
                ESTADO = GET_OPERANDS

            continue

        elif ESTADO == GET_JC_OPERANDS:

            if dictsOfOperands[0]['type'] == IMMEDIATE_OPCODE:
                offsets_to_jump = "Label_%08X" % (getImmediateValue(dictsOfOperands[0]['size']))
                dictsOfOperands = dictsOfOperands[1:]

            inst_aux = "CMP "

            for i in dictsOfOperands:
                if i['type'] == IMMEDIATE_OPCODE:
                    inst_aux += "0%Xh" % (getImmediateValue(i['size']))
                elif i['type'] == REGISTER_OPCODE:
                    opcodeRegister = codeOfVM[INDEX]
                    INDEX += 1
                    inst_aux += getRegister(opcodeRegister) + " "
                elif i['type'] == ADDRESS_OPCODE:
                    opcodeRegister = codeOfVM[INDEX]
                    INDEX += 1
                    inst_aux += "[HardcodedString + " + getRegister(opcodeRegister) + "]"
                elif i['type'] == SERIAL_HASH_OPCODE:
                    hash_offset = getImmediateValue(i['size'])
                    instruction += "[HardcodedString + 0%08Xh]" % hash_offset
                else:
                    print "ERROR type %02x not supported...Aborting" % (i['type'])
                    exit(-1)
                inst_aux += ', '

            if inst_aux[-2] == ',':
                inst_aux = inst_aux[:-2]

            if ('[HardcodedString' in inst_aux):
                inst_aux = AddPrefixMov(inst_aux)

            if('REG0x24' in inst_aux or 'REG0x28' in inst_aux):
                inst_aux = FixFalseRegisters(inst_aux)

            instruction = inst_aux + '\n\t\t\t' + instruction + " " + offsets_to_jump

            ESTADO = END_NORMAL

        elif ESTADO == GET_OPERANDS:
            for i in dictsOfOperands:
                if i['type'] == IMMEDIATE_OPCODE:
                    OFFSET = (getImmediateValue(i['size']))
                    if CALL_JMP:
                        instruction += "VIRTUAL_FUNCTION_%08X" % OFFSET
                    elif JMP_OP:
                        instruction += "Label_%08X" % OFFSET
                    else:
                        instruction += "0%Xh" % OFFSET
                        instruction += " "
                elif i['type'] == REGISTER_OPCODE:
                    opcodeRegister = codeOfVM[INDEX]
                    INDEX += 1
                    instruction += getRegister(opcodeRegister) + " "
                elif i['type'] == ADDRESS_OPCODE:
                    opcodeRegister = codeOfVM[INDEX]
                    INDEX += 1
                    instruction += "[HardcodedString + " + getRegister(opcodeRegister) + "]"
                elif i['type'] == SERIAL_HASH_OPCODE:
                    hash_offset = getImmediateValue(i['size'])
                    instruction += "[HardcodedString + 0%08Xh]" % hash_offset
                else:
                    print "ERROR type %02x not supported...Aborting" % (i['type'])
                    exit(-1)

                instruction += ', '

            if instruction[-2] == ',':
                instruction = instruction[:-2]

            if ('[HardcodedString' in instruction):
                instruction = AddPrefixMov(instruction)

            if ('REG0x24' in instruction or 'REG0x28' in instruction):
                instruction = FixFalseRegisters(instruction)

            ESTADO = END_NORMAL
            continue

        elif ESTADO == END_NORMAL:
            print "[!] Final instruction: \n%s" % (instruction)
            archivo.write(instruction + '\n\n')

            if CALL_JMP:
                ESTADO = END_CALL
            elif IS_RET:
                ESTADO = END_RET
            else:
                ESTADO = INIT

            continue

        elif ESTADO == END_CALL:

            if OFFSET not in LIST_OF_FUNCTION_OFFSETS:
                LIST_OF_FUNCTION_OFFSETS.append(OFFSET)

            ESTADO = INIT
            continue

        elif ESTADO == END_RET:

            archivo.write("%s\tendp\n\n" % Function_Name)

            IS_IN_CALL = False

            ESTADO = INIT
            continue

def main():
    print 'VM Genaytyk x86 Disassembler'
    scripter_pipter()



if __name__ == '__main__':
    main()